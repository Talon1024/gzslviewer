#!/usr/bin/env python3
import re
import argparse
import os.path
import os
import stat
import subprocess
import sys
import glob
import tempfile

cli = False
try:
    from tkinter import *
    from tkinter import filedialog
    from tkinter import ttk
except ImportError:
    cli = True

re_string = r'(".+[^\\]"|\S+)'
re_shaderinfo = r"hardwareshader\s+(\S+)\s+" + re_string
re_gldefs_include = r"#include\s+" + re_string
re_comment = r"(?:/\*.+\*/)|(?://[^\n]+)"
re_letter = re.compile(r"([A-Za-z])")
re_float = r"(-?\d+(?:\.\d+(?:e\d+)?)?)"
re_shader = r"Shader\s+" + re_string
re_texture = r"Texture\s+" + re_string + r"\s+" + re_string
re_speed = r"Speed\s+" + re_float
re_define = r"define\s+" + re_string + r"\s*=\s*" + re_string

SHADER_TYPE_TEXTURE = "TEXTURE_SHADER"
SHADER_TYPE_POSTPROCESS = "POSTPROCESS_SHADER"


class LumpManager:
    def __init__(self, modpath):
        self.lump_files = {}
        self.gldefs_files = []
        self._modpath = modpath
        mod_glob = os.path.join(modpath, r"**/*")
        for lumpfn in glob.iglob(mod_glob, recursive=True):
            lumppath = os.path.relpath(lumpfn, modpath).lower()
            self.lump_files[lumppath] = lumpfn
            shortname = LumpManager.lump_name(os.path.basename(lumpfn))
            self.lump_files[shortname] = lumpfn
            if shortname == "gldefs":
                self.gldefs_files.append(lumppath)

    def __getitem__(self, key):
        fname = key.lower()
        if "/" not in key:  # Not full path
            fname = LumpManager.lump_name(key)
        return self.lump_files[fname]

    @staticmethod
    def lump_name(filename):
        filename = filename.lower()
        dot_pos = filename.find(".")
        if dot_pos >= 0:
            filename = filename[:dot_pos]
        if len(filename) > 8:
            filename = filename[:8]
        return filename

    def open(self, filename, *args, **kwargs):
        filepath = self[filename]
        return open(filepath, *args, **kwargs)


class GZSLViewerGUI:
    def __init__(self, root, glslviewer_available):
        self.manager = None
        self.shaderlist = []
        self.shader_name_indices = {}
        # self.shader_alphabet = {}
        self.mod_set = False
        self.glslviewer_set = bool(glslviewer_available)
        self.glslviewer_available = glslviewer_available
        root.title("GZSLViewer")
        # +--------------------------------------+
        # | GLSLViewer path: ______..  |Browse|  |
        # | Mod path: _____________..  |Browse|  |
        # | 3D model (opt.): |____..|  |Browse|  |
        # | Shader:  |______________________|V|  |
        # | | View |                 | Cancel |  |
        # | Uniforms:                            |
        # | +---------------+                    |
        # | | uObjectColor  |                    |
        # | | uObjectColor2 |                    |
        # | |               |                    |
        # | +---------------+                    |
        # | Textures:                            |
        # | +--------+  +---------------------+  |
        # | |WATR_A00|  |                     |  |
        # | |WFNOISE |  |   Texture image     |  |
        # | |        |  |                     |  |
        # | +--------+  +---------------------+  |
        # +--------------------------------------+
        glslviewer_row_add = 0
        if not glslviewer_available:
            glslviewer_row_add = 1
        glslviewer_row = -1 + glslviewer_row_add
        mod_path_row = 0 + glslviewer_row_add
        model_row = 1 + glslviewer_row_add
        shader_row = 2 + glslviewer_row_add
        control_row = 3 + glslviewer_row_add
        texture_row = 4 + glslviewer_row_add
        # Content frame
        mainframe = ttk.Frame(root, padding="2 2 2 2")
        mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        mainframe.columnconfigure(1, weight=1)
        # If GLSLViewer isn't available...
        self.glslviewer_path = StringVar()
        view_state = "normal"
        if not glslviewer_available:
            ttk.Label(mainframe, text="GLSLViewer path:").grid(column=0, row=glslviewer_row)
            ttk.Label(mainframe, textvariable=self.glslviewer_path).grid(column=1, columnspan=2, row=glslviewer_row)
            ttk.Button(mainframe, text="Browse", command=self.ask_glslviewer_path).grid(column=3, row=glslviewer_row)
            view_state = "disabled"
        else:
            self.glslviewer_path.set(glslviewer_available)
        # Top row - mod selection
        self.modpath = StringVar()
        ttk.Label(mainframe, text="Mod path:").grid(column=0, row=mod_path_row)
        ttk.Label(mainframe, textvariable=self.modpath).grid(column=1, columnspan=2, row=mod_path_row)
        ttk.Button(mainframe, text="Browse", command=self.ask_mod_path).grid(column=3, row=mod_path_row)
        # Model selector
        self.modelpath = StringVar()
        ttk.Label(mainframe, text="3D model (optional)").grid(column=0, row=model_row)
        ttk.Entry(mainframe, textvariable=self.modelpath, validate="focus", validatecommand=self.validate_model).grid(column=1, row=model_row, columnspan=2)
        ttk.Button(mainframe, text="Browse", command=self.ask_model_path).grid(column=3, row=model_row)
        # Shader selector
        ttk.Label(mainframe, text="Shader:").grid(column=0, row=shader_row)
        self.cbo_shaders = ttk.Combobox(mainframe, state="readonly")
        self.cbo_shaders.grid(column=1, columnspan=2, row=shader_row)
        self.cbo_shaders.bind("<<ComboboxSelected>>", self.set_shader)
        # Color picker - uObjectColor and uObjectColor2
        # ttk.Label(mainframe, text="uObjectColor").grid(column=0, row=3)
        # Main controls
        self.btn_view = ttk.Button(mainframe, text="View", state=view_state, command=self.view)
        self.btn_view.grid(column=0, columnspan=2, row=control_row)
        root.mainloop()

    def ask_mod_path(self):
        self.modpath.set(filedialog.askdirectory(title="Select mod folder", mustexist=True))
        self.on_select_mod()

    def ask_model_path(self):
        self.modelpath.set(filedialog.askopenfilename(
            filetypes=(("OBJ", ".obj"),)
        ))

    def ask_glslviewer_path(self):
        path_to_check = filedialog.askdirectory(
            title="Select GLSLViewer folder", mustexist=True)
        glslviewer_path = is_glslviewer_path(path_to_check)
        if not glslviewer_path:
            self.glslviewer_path.set("")
        else:
            self.glslviewer_path.set(glslviewer_path)
            self.glslviewer_set = True
        self.check_view()

    def validate_model(self):
        if self.modelpath.get() == "":
            return True
        re_obj = r"\.obj"
        if not re.search(re_obj, self.modelpath.get(), re.IGNORECASE):
            # Model must be an OBJ!
            self.modelpath.set("")
            return False
        if not os.path.lexists(self.modelpath.get()):
            self.modelpath.set("")
            return False
        return True

    def on_select_mod(self):
        self.manager = LumpManager(self.modpath.get())
        self.shaderlist = get_shaders(self.manager)
        shaderlist = []
        for index, shaderdef in enumerate(self.shaderlist):
            shader_name = str(shaderdef)
            # shader_letter = shader_name.lower()[0]
            self.shader_name_indices[shader_name] = index
            # self.shader_alphabet.setdefault(shader_letter, [])
            # self.shader_alphabet[shader_letter].append(shader_name)
            shaderlist.append(shader_name)
        self.cbo_shaders["values"] = shaderlist
        self.mod_set = len(shaderlist) > 0
        self.check_view()

    def set_shader(self, tk_event):
        tk_event.widget.selection_clear()

    def check_view(self):
        if self.glslviewer_set and self.mod_set:
            self.btn_view.state(["!disabled"])
        else:
            self.btn_view.state(["disabled"])

    def view(self):
        shader_name = self.cbo_shaders.get()
        if shader_name not in self.shader_name_indices:
            return
        shader_index = self.shader_name_indices[shader_name]
        model_name = self.modelpath.get()
        if model_name == "":
            model_name = None
        glslviewer_path = self.glslviewer_path.get()
        self.shaderlist[shader_index].view(glslviewer_path, model_name)
        self.shaderlist[shader_index].cleanup()


class ShaderDefinition:
    frag_suffix = ".frag"

    def __init__(self, identifier, main_texture, shader, speed, defines,
                 textures, manager, shader_type=SHADER_TYPE_TEXTURE):
        self.identifier = identifier
        self.main_texture = main_texture
        self.shader = shader
        self.speed = speed
        self.defines = defines
        self.textures = tuple(textures.items())
        self.manager = manager
        self.shader_type = shader_type

    @staticmethod
    def fix_glsl_text(text):
        text = re.sub(r"gl_TexCoord\[0\]", "vTexCoord", text, re.IGNORECASE)
        text = re.sub(
            r"vec4\s+ProcessTexel\s*\([^)]*\)",
            "vec4 Process(vec4 _c_o_l_o_r_)",
            text, re.IGNORECASE
        )
        text = re.sub(r"uniform\s+float\s+timer;", "", text, re.IGNORECASE)
        return text

    def convert_shader(self):
        define_bool = "#define {}\n"
        define_kvpair = "#define {} {}\n"
        uniform_texture = "uniform sampler2D {};\n"
        with self.manager.open(self.shader, "r") as shader_file, (
            tempfile.NamedTemporaryFile("w", suffix=self.frag_suffix,
                                        delete=False)) as temp_shader:
            self.temp_shader_path = temp_shader.name
            temp_shader.write("#version 330 core\n")
            temp_shader.write(define_bool.format(self.shader_type))
            for uniform_index, extra_texture in enumerate(self.textures):
                uniform_name = "u_tex{}".format(uniform_index + 1)
                temp_shader.write(uniform_texture.format(uniform_name))
                temp_shader.write(define_kvpair.format(
                    extra_texture[0], uniform_name))
            temp_shader.write("#include \"gzcompat.frag\"\n")
            for shader_text in shader_file:
                shader_text = ShaderDefinition.fix_glsl_text(shader_text)
                temp_shader.write(shader_text)
        return self.temp_shader_path

    def get_glslviewer_args(self, glslviewer_path, model_path=None):
        argu = [glslviewer_path, "-vFlip",
                self.convert_shader(),
                self.main_texture]
        for texture in self.textures:
            argu.append(self.manager[texture[1]])
        if model_path and self.shader_type != SHADER_TYPE_POSTPROCESS:
            argu.append(model_path)
        for define in self.defines.items():
            define_str = "-D{0},{1}".format(*define)
            argu.append(define_str)
        return argu

    def view(self, glslviewer_path="./glslViewer", model_path=None):
        argu = self.get_glslviewer_args(glslviewer_path, model_path)
        viewer_env = os.environ
        viewer_env["MESA_GL_VERSION_OVERRIDE"] = "3.30"
        subprocess.run(argu, env=viewer_env)

    def cleanup(self):
        os.remove(self.temp_shader_path)

    def __str__(self):
        return self.identifier

def get_shaders(manager):

    def parse_include(match):
        include_fname = match.group(1).strip("\"")
        with manager.open(include_fname, "r") as include_file:
            include_text = include_file.read()
        return include_text

    gldefs_text = ""
    for gldefs_path in manager.gldefs_files:
        with manager.open(gldefs_path, "r") as gldefs_file:
            gldefs_text += gldefs_file.read()

    gldefs_text = re.sub(re_gldefs_include, parse_include,
                         gldefs_text, flags=re.IGNORECASE)
    gldefs_text = re.sub(re_comment, "", gldefs_text, flags=re.DOTALL)
    shader_defs = []

    for shader_match in re.finditer(re_shaderinfo, gldefs_text, re.IGNORECASE):
        # TODO: Post-processing shader support
        if shader_match.group(1).lower() == "postprocess":
            continue
        def_start = gldefs_text.find("{", shader_match.start(1))
        def_end = gldefs_text.find("}", shader_match.start(1))
        shader_def = gldefs_text[def_start:def_end]
        raw_texname = shader_match.group(2).lower().strip("\"")

        texname = manager[raw_texname]
        speed = 1
        defines = {}
        textures = {}
        shader_match = re.search(re_shader, shader_def, re.IGNORECASE)
        # Shader filename is required
        if shader_match:
            try:
                shader_fname = shader_match.group(1).strip("\"")
            except IndexError:
                # Invalid shader
                continue
        else:
            continue
        speed_match = re.search(re_speed, shader_def, re.IGNORECASE)
        if speed_match:
            speed = float(speed_match.group(1))
        for define_match in re.finditer(re_define, shader_def, re.IGNORECASE):
            defines[define_match.group(1)] = define_match.group(2)
        for texture_match in re.finditer(re_texture, shader_def, re.IGNORECASE):
            texture_name = texture_match.group(1).strip("\"")
            texture_file = texture_match.group(2).strip("\"")
            textures[texture_name] = texture_file
        shader_defs.append(ShaderDefinition(
            raw_texname, texname, shader_fname, speed, defines, textures,
            manager))
    return shader_defs


def is_glslviewer_path(path):
    def case_desensitize(letter):
        lower = letter.group(1).lower()
        upper = letter.group(1).upper()
        return "[" + lower + upper + "]"
    glslviewer_exename = "glslviewer"
    if sys.platform == "win32" or sys.platform == "cygwin":
        glslviewer_exename += ".exe"
    glslviewer_glob = os.path.join(
        path, re.sub(re_letter, case_desensitize, glslviewer_exename))
    glslviewer_results = glob.glob(glslviewer_glob)
    try:
        glslviewer_incwd = glslviewer_results[0]
    except IndexError:
        return None
    glslviewer_stat = os.stat(glslviewer_incwd)
    mode = glslviewer_stat.st_mode
    if (stat.S_ISREG(mode) and  # Ensure glslviewer is a regular file
            # And ensure it is executable
            os.access(glslviewer_incwd, os.R_OK | os.X_OK)):
        return glslviewer_incwd
    return None


def run():
    glslviewer_incwd = is_glslviewer_path(os.getcwd())
    if cli:
        if not glslviewer_incwd:
            print("Please run this in GLSLViewer's folder!", file=sys.stderr)
            exit(1)
        # Parse CLI arguments
        parser = argparse.ArgumentParser(
            description="Load a GZDoom shader into glslviewer"
        )
        parser.add_argument("path", help="Path to mod folder")
        parser.add_argument("--model", help="Path to 3D model (OBJ)")
        parser.add_argument("--uObjectColor", help="Value of uObjectColor uniform")
        parser.add_argument("--uObjectColor2", help="Value of uObjectColor2 uniform")
        args = parser.parse_args()
        mod_lumps = LumpManager(args.path)
        # Prompt user and run GLSLViewer
        shader_defs = get_shaders(mod_lumps)
        print("Select a shader to view:")
        for index, shader in enumerate(shader_defs):
            print("{}. {}".format(index + 1, shader.identifier))
        shader_to_view = input(">")
        shader_index = int(shader_to_view, 10) - 1
        shader_defs[shader_index].view(glslviewer_incwd, args.model)
        shader_defs[shader_index].cleanup()
    else:
        GZSLViewerGUI(Tk(), glslviewer_incwd)

if __name__ == "__main__":
    run()
